%!TEX root = ../artigo.tex
\section{Subprogramas Genéricos} % (fold)
\label{sec:subprogramas_genericos}
No desenvolvimente de software, o reuso do código fonte é um fator importante para aumentar a produtividade e diminuir gastos. Uma maneira de conseguir esse reuso seria fazer um único subprograma funcionar para qualquer tipo de dados. Com isso, por exemplo, não precisamos criar um subprograma de ordenação para cada tipo de dado existente.

Um subprograma polimórfico é algo que pode nos oferecer esse tipo de reuso. Segundo Sebesta \cite{sebesta}, há três tipos de polimorfismo, sendo eles:
\begin{description}
	\item[Ad Hoc:] Consiste na sobrecarga de subprogramas, conforme mostrado na seção \ref{sec:sobrecarga_de_subprogramas}.
	\item[Subtipo:] Específico para linguagens orientadas a objeto, que não está dentro do escopo deste trabalho, mas pode ser encontrado em \cite{poli_java}.
	\item[Paramétrico:] Baseia-se do uso de tipos genéricos, onde esse tipo genérico pode assumir qualquer tipo de dado. Esta seção irá abordar esse tipo de polimorfismo.
\end{description}

Subprogramas com polimorfismo paramétrico são subprogramas que utilizam tipos de dados genéricos, o que possibilita seu reuso para cada tipo de dado. A seguir, iremos exemplificar o uso dessa técnica em C++, Java e C\#.

%-------------Templates em C++
\subsection{Template em C++} % (fold)
\label{sub:template_em_c}
Em C++, funções genéricas são obtidas através do uso de \emph{templates} \cite{template_cpluplus}. Primeiro, é necessário declarar um template, fazendo-o da seguinte forma:
\begin{verbatim}
template <template parameters>
\end{verbatim}

Um \emph{template parameter} pode ter uma das seguintes formas
\begin{verbatim}
class identifier
typename identifier
\end{verbatim}

Segundo Sebesta \cite{sebesta}, a palavra chave \emph{class} é utilizada para especificar tipos e \emph{typename} é necessária para especificar um valor absoluto.

Como exemplo, vamos declarar um função template, que retorna o maior valor entre dois dados. A declaração é feita da seguinte forma
\begin{verbatim}
template <class myType>
myType GetMax (myType a, myType b) {
   return (a>b?a:b);
}
\end{verbatim}

Para chamarmos \emph{GetMax} para dois inteiros, fazemos da seguinte maneira
\begin{verbatim}
GetMax<int> (1,2);
\end{verbatim}

Para trocar o tipo dos parâmetros da função \emph{GetMax}, basta trocar o tipo de dados ao charmar a função em questão (por exemplo, de \emph{int} para \emph{float}).

\emph{Templates} podem ser utilizado em classes, podem ser aninhados e também podem possuir especializações. Explicar essas funcionalidades não faz parte do escopo deste trabalho, mas isso pode ser obtido em \cite{template_cpluplus}.
% subsection template_em_c (end)

%-------------Métodos Genéricos em Java
\subsection{Métodos Genéricos em Java} % (fold)
\label{sub:metodos_genericos_em_java}
Em Java, podemos fazer o uso de métodos genéricos, sendo similar aos \emph{templates} de C++. Um exemplo de um método genérico em Java é como segue
\begin{verbatim}
public static <T> T doIt(T[] list) {
   ...
}
\end{verbatim}

Onde é definido o método \emph{doIt} que recebe como parâmetro uma lista de tipos genéricos. O método \emph{doIt} pode ser chamado passando uma lista do tipo \emph{String} da seguinte forma
\begin{verbatim}
	doIt<String>(myList);
\end{verbatim}

Diferentemente de C++, os tipos genéricos em java devem ser uma classe, não podendo ser um valor absoluto ou um tipo primitivo. Além do mais, Java permite que limitamos os tipos genéricos, como informando de qual classe ele deve herdar ou qual interface deve implementar \cite{sebesta}.

Tipos genéricos em Java nos fornece muitos outros recursos (como \emph{Wildcards}), que não abordados neste trabalho, mas que podem ser encontrados com detalhes em \cite{generics_java}.
% subsection metodos_genericos_em_java (end)

%-------------Métodos Genéricos em C#
\subsection{Métodos Genéricos em C\#} % (fold)
\label{sub:metodos_genericos_em_c_sharp}
Métodos genéricos em C\# tem as mesmas funcionalidades de Java, porém não suportam \emph{wildcards}. Uma diferença em C\# é que o tipo do argumento pode ser omitido caso o compilador poder inferir o tipo \cite{sebesta}. 

Mais informações e exemplos sobre tipos genéricos em C\# podem ser encontrados em \cite{generics_msdn}.
% subsection metodos_genericos_em_c_sharp (end)

% section subprogramas_genericos (end)

